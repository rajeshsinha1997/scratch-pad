Increment and Decrement Operators:
------------------------------------
--> We can apply 'increment' and 'decrement' operators only for variables, and not for constant values. If we are trying to do so, then we will get compile-time error.

--> Nesting of 'increment' and 'decrement' operators are not allowed.

--> For 'final' variables, we can't apply 'increment' and 'decrement' operators.

--> We can apply 'increment' and 'decrement' operators for every primitive type, except for 'boolean' type.

--> Difference between 'b++' and 'b=b+1':
    -------------------------------------
    If we apply any arithmetic operator between two variables 'a' and 'b', the result type is always
    'max(int, type_of_a, type_of_b)'. But in the case of 'increment' and 'decrement' operators, internal type-casting will be performed automatically.



Arithmetic Operators:
---------------------
--> If we apply any arithmetic operators between two variables 'a' and 'b', the result type is always,

                                max(int, type_of_a, type_of_b)

--> Infinity: In integral arithmetic (byte, short, int, long), there is no way to represent 'Infinity'. Hence, if 'Infinity' is the result, we will get 'ArithmeticException' in integral arithmetic. But, in floating-point arithmetic (float, double), there is a way to represent 'Infinity'. For this, 'Float' and 'Double' classes contains the constants 'POSITIVE_INFINITY' and 'NEGATIVE_INFINITY'. Hence, even though the result is 'Infinity', we won't get any 'ArithmeticException' in floating-point arithmetic.

--> NaN (Not a Number): In integral arithmetic (byte, short, int, long), there is no way to represent 'undefined' values. Hence, if the result is 'undefined', we will get RuntimeException saying 'ArithmeticException: / by zero'. But, in floating-point arithmetic (float, double), there is a way to represent 'undefined' results. For this, 'Float' and 'Double' classes contains the constant 'NaN'. Hence, if the result is 'undefined', we won't get any 'ArithmeticException' in floating-point arithmetic.

--> For any value 'x' including 'NaN', the following expressions returns the value 'false',
    * x < NaN
    * x <= NaN
    * x > NaN
    * x >= NaN
    * x == NaN

--> For any value 'x' including 'NaN', the following expressions returns the value 'true',
    * x != NaN

--> The 'ArithmeticException' in Java is a 'RuntimeException' and not 'Compile Time Error', and it is possible to encounter only in integral arithmetic but not in floating-point arithmetic.

--> The only operators which cause the 'ArithmeticException' are '/' and '%'.



String Concatenation Operator ('+'):
------------------------------------
--> The only overloaded operator in Java is the '+' operator. Sometimes it acts as an arithmetic addition operator, and sometimes it acts as a String concatenation operator. If at least one argument is of String type, then the '+' operator acts as the String concatenation operator, and, if both of the arguments are of Number type, then the '+' operator acts as the arithmetic addition operator.



Relational Operators:
---------------------
--> We can apply relational operators for every primitive type, except for 'boolean' type.

--> We can't apply relational operators for 'Object' types.

--> Nesting of relational operators is not allowed in Java. We will get compile-time error if we do so.



Equality Operators:
-------------------
--> We can apply equality operators for every primitive type, including 'boolean' type also.

--> We can apply equality operators for object types also. For two object references 'r1' and 'r2', 'r1 == r2' returns 'true', if and only if both are referencing to the same object (reference/address comparison).

--> If we apply equality operators for object types, then compulsory there should be some relation between the types of the arguments (either child and parent or of the same type), otherwise we will get compile-time error.

* Difference between '==' operator and 'equals()' method:
  -------------------------------------------------------
  In general, we can use '==' operator for reference comparison (address comparison), and 'equals()' method for content comparison.

--> For any object reference 'r', the expression 'r == null' will always be evaluated to the value 'false'. But, the expression 'null == null' will always be evaluated to 'true'.



'instanceof' Operator:
----------------------
--> We can use the 'instanceof' operator to check whether a given object is of a particular type or not.

--> The syntax of the 'instanceof' operator is as follows,

                                            'r instanceof X'
    
    where,
    r - object reference
    X - name  of a class or interface

--> To use the 'instanceof' operator, compulsory there should be some relation between the argument types. Either it has to be child to parent or they have to be of the same type. Otherwise, we will get compile-time error.

--> For any class or interface 'X', the expression 'null instanceof X' will always be evaluated to 'false'.



Bitwise Operators:
------------------
--> We can apply bitwise operators ('&', '|', '^') for both boolean types and integral types.



Bitwise Complement Operator (~):
--------------------------------
--> We can apply the bitwise complement operator only for the integral types, but not for the boolean types. If we are trying to apply this operator for boolean types, then we will get compile-time error.



Boolean Complement Operator (!):
--------------------------------
--> We can apply boolean complement operator only for the boolean types, but not for the integral types.
